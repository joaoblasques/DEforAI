# 01. Architectural Patterns for ML Systems

**Chapter:** Data Architecture for ML Systems
**Topic:** Common architectural patterns and design principles for scalable ML systems

---

## üìã Overview

ML systems require architectural patterns that address unique challenges beyond traditional software systems: handling massive datasets, supporting iterative experimentation, managing model versions, and serving predictions at scale. This subchapter explores proven architectural patterns specifically designed for ML systems, from monolithic to microservices, event-driven to service mesh architectures.

**Key Industry Reality (2024-2025):** Microservices architecture with event-driven patterns has become the de facto standard for production ML systems. Modern platforms leverage service mesh (Istio, Linkerd) for observability, KServe for model serving, and Argo Workflows for ML pipelines. The trend is toward "ML as a platform" where data engineering, model training, and serving are independent, loosely coupled services.

**Critical Challenge:** Balancing the complexity of distributed systems with the need for rapid ML experimentation. Over-engineering too early can slow down iteration, while under-engineering leads to scalability and reliability issues in production.

---

## üéØ Learning Objectives

After completing this subchapter, you will be able to:
- Identify and apply appropriate architectural patterns for different ML use cases
- Design ML systems using microservices and event-driven architectures
- Understand trade-offs between monolithic, modular, and distributed ML architectures
- Implement separation of concerns in ML systems (data, features, training, serving)
- Choose appropriate patterns for specific requirements (latency, scale, complexity)
- Design fault-tolerant and observable ML architectures
- Apply Domain-Driven Design (DDD) principles to ML systems
- Integrate ML components using APIs, events, and message queues

---

## üìö Core Concepts

### 1. ML System Architecture Evolution

#### Stage 1: Monolithic ML System

**Description:** All ML components (data processing, feature engineering, training, serving) in a single application.

**Architecture:**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         Monolithic ML Application                  ‚îÇ
‚îÇ                                                     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ Data Ingestion & Processing                  ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                     ‚Üì                              ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ Feature Engineering                          ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                     ‚Üì                              ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ Model Training                               ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                     ‚Üì                              ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ Model Serving / Prediction API               ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Example:**
```python
# monolithic_ml_app.py - All in one Flask app

from flask import Flask, request, jsonify
import pandas as pd
import joblib
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import RandomForestClassifier

app = Flask(__name__)

class MonolithicMLApp:
    """
    All ML functionality in a single application
    """

    def __init__(self):
        self.scaler = StandardScaler()
        self.model = None

    def load_data(self, filepath: str):
        """Load and process data"""
        df = pd.read_csv(filepath)
        # Data cleaning
        df = df.dropna()
        df = df[df['age'] > 0]
        return df

    def engineer_features(self, df: pd.DataFrame):
        """Feature engineering"""
        df['age_squared'] = df['age'] ** 2
        df['income_per_age'] = df['income'] / df['age']
        return df

    def train(self, df: pd.DataFrame):
        """Train model"""
        X = df.drop('target', axis=1)
        y = df['target']

        # Scale features
        X_scaled = self.scaler.fit_transform(X)

        # Train model
        self.model = RandomForestClassifier(n_estimators=100)
        self.model.fit(X_scaled, y)

        # Save model
        joblib.dump(self.model, 'model.pkl')
        joblib.dump(self.scaler, 'scaler.pkl')

    def predict(self, input_data: dict):
        """Serve predictions"""
        if not self.model:
            self.model = joblib.load('model.pkl')
            self.scaler = joblib.load('scaler.pkl')

        # Convert to DataFrame
        df = pd.DataFrame([input_data])

        # Engineer features (same as training!)
        df = self.engineer_features(df)

        # Scale
        X_scaled = self.scaler.transform(df)

        # Predict
        prediction = self.model.predict_proba(X_scaled)[0, 1]

        return float(prediction)


ml_app = MonolithicMLApp()

@app.route('/train', methods=['POST'])
def train():
    """Train endpoint"""
    data = ml_app.load_data('training_data.csv')
    data = ml_app.engineer_features(data)
    ml_app.train(data)
    return jsonify({"status": "trained"})

@app.route('/predict', methods=['POST'])
def predict():
    """Prediction endpoint"""
    input_data = request.json
    prediction = ml_app.predict(input_data)
    return jsonify({"prediction": prediction})

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
```

**Pros:**
- ‚úÖ Simple to develop and deploy
- ‚úÖ Easy to debug (single codebase)
- ‚úÖ Low latency (no network calls)
- ‚úÖ Good for prototypes and small teams

**Cons:**
- ‚ùå Tight coupling (changing features requires redeploying serving)
- ‚ùå Hard to scale components independently
- ‚ùå Single point of failure
- ‚ùå Difficult to have separate teams own different components
- ‚ùå Deployment risk (all or nothing)

**When to Use:**
- Early-stage projects
- Small datasets (<100GB)
- Low request volume (<100 QPS)
- Proof of concepts

---

#### Stage 2: Modular ML System

**Description:** ML components separated into modules with clear interfaces, but deployed together.

**Architecture:**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         Modular ML Application                       ‚îÇ
‚îÇ                                                      ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îÇ
‚îÇ  ‚îÇData Pipeline ‚îÇ  ‚îÇFeature Store ‚îÇ  ‚îÇModel Mgmt ‚îÇ‚îÇ
‚îÇ  ‚îÇ   Module     ‚îÇ‚Üí ‚îÇ   Module     ‚îÇ‚Üí ‚îÇ  Module   ‚îÇ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îÇ
‚îÇ                                            ‚Üì        ‚îÇ
‚îÇ                                   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                   ‚îÇ Serving Module ‚îÇ‚îÇ
‚îÇ                                   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Example:**
```python
# Modular architecture with clear separation

# data_pipeline.py
class DataPipeline:
    """Responsible for data ingestion and processing"""

    def extract(self, source: str) -> pd.DataFrame:
        """Extract data from source"""
        return pd.read_csv(source)

    def transform(self, df: pd.DataFrame) -> pd.DataFrame:
        """Transform and clean data"""
        df = df.dropna()
        df = df[df['age'] > 0]
        return df

    def load(self, df: pd.DataFrame, destination: str):
        """Load to destination"""
        df.to_parquet(destination)


# feature_engineering.py
class FeatureEngineering:
    """Responsible for feature creation"""

    def create_features(self, df: pd.DataFrame) -> pd.DataFrame:
        """Create features from raw data"""
        df['age_squared'] = df['age'] ** 2
        df['income_per_age'] = df['income'] / df['age']
        return df

    def get_feature_schema(self) -> dict:
        """Return feature definitions for serving"""
        return {
            'age_squared': 'int64',
            'income_per_age': 'float64'
        }


# model_training.py
class ModelTraining:
    """Responsible for model training and evaluation"""

    def __init__(self):
        self.scaler = StandardScaler()

    def train(self, X: pd.DataFrame, y: pd.Series) -> Any:
        """Train and return model"""
        X_scaled = self.scaler.fit_transform(X)
        model = RandomForestClassifier(n_estimators=100)
        model.fit(X_scaled, y)
        return model

    def evaluate(self, model: Any, X: pd.DataFrame, y: pd.Series) -> dict:
        """Evaluate model performance"""
        X_scaled = self.scaler.transform(X)
        predictions = model.predict_proba(X_scaled)[:, 1]
        auc = roc_auc_score(y, predictions)
        return {"auc": auc}


# model_serving.py
class ModelServing:
    """Responsible for serving predictions"""

    def __init__(self):
        self.model = None
        self.scaler = None
        self.feature_eng = FeatureEngineering()

    def load_model(self, model_path: str):
        """Load model artifacts"""
        self.model = joblib.load(f"{model_path}/model.pkl")
        self.scaler = joblib.load(f"{model_path}/scaler.pkl")

    def predict(self, input_data: dict) -> float:
        """Generate prediction"""
        # Convert to DataFrame
        df = pd.DataFrame([input_data])

        # Apply same feature engineering as training
        df = self.feature_eng.create_features(df)

        # Scale
        X_scaled = self.scaler.transform(df)

        # Predict
        prediction = self.model.predict_proba(X_scaled)[0, 1]

        return float(prediction)


# main.py - Orchestrate modules
if __name__ == '__main__':
    # Data pipeline
    data_pipeline = DataPipeline()
    raw_data = data_pipeline.extract('raw_data.csv')
    clean_data = data_pipeline.transform(raw_data)
    data_pipeline.load(clean_data, 'processed_data.parquet')

    # Feature engineering
    feature_eng = FeatureEngineering()
    features_df = feature_eng.create_features(clean_data)

    # Model training
    trainer = ModelTraining()
    X = features_df.drop('target', axis=1)
    y = features_df['target']
    model = trainer.train(X, y)

    # Save model
    joblib.dump(model, 'models/model.pkl')
    joblib.dump(trainer.scaler, 'models/scaler.pkl')

    # Serving
    serving = ModelServing()
    serving.load_model('models/')
    prediction = serving.predict({'age': 35, 'income': 50000})
    print(f"Prediction: {prediction}")
```

**Pros:**
- ‚úÖ Better separation of concerns
- ‚úÖ Easier testing (test modules independently)
- ‚úÖ Reusable components
- ‚úÖ Multiple teams can work on different modules

**Cons:**
- ‚ùå Still deployed as one unit
- ‚ùå Cannot scale components independently
- ‚ùå Deployment coupling (all modules deploy together)

**When to Use:**
- Medium-sized teams (5-15 people)
- Medium datasets (100GB-1TB)
- Moderate request volume (100-1K QPS)
- Need for code organization

---

#### Stage 3: Microservices ML System

**Description:** ML components as independent services communicating via APIs or events.

**Architecture:**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Data      ‚îÇ API  ‚îÇ   Feature    ‚îÇ API  ‚îÇ   Model     ‚îÇ
‚îÇ  Service    ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí‚îÇ   Service    ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí‚îÇ  Training   ‚îÇ
‚îÇ             ‚îÇ      ‚îÇ              ‚îÇ      ‚îÇ  Service    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚îÇ                      ‚îÇ
                            ‚îÇ API                  ‚îÇ Registry
                            ‚Üì                      ‚Üì
                     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                     ‚îÇ   Model      ‚îÇ      ‚îÇ   Model     ‚îÇ
                     ‚îÇ  Serving     ‚îÇ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ  Registry   ‚îÇ
                     ‚îÇ  Service     ‚îÇ      ‚îÇ  Service    ‚îÇ
                     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚Üë
                            ‚îÇ API
                     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                     ‚îÇ  API Gateway ‚îÇ
                     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Implementation:**
```python
# data_service.py - Independent microservice
from fastapi import FastAPI
import pandas as pd

app = FastAPI(title="Data Service")

@app.post("/extract")
async def extract_data(source: str):
    """Extract data from source"""
    df = pd.read_csv(source)
    return {"status": "extracted", "rows": len(df)}

@app.post("/transform")
async def transform_data(data: dict):
    """Transform and clean data"""
    df = pd.DataFrame(data['records'])
    df = df.dropna()
    df = df[df['age'] > 0]
    return df.to_dict(orient='records')


# feature_service.py - Independent microservice
from fastapi import FastAPI
import httpx

app = FastAPI(title="Feature Service")

@app.post("/compute_features")
async def compute_features(user_id: str):
    """Compute features for a user"""
    # Fetch data from Data Service
    async with httpx.AsyncClient() as client:
        response = await client.get(f"http://data-service/user/{user_id}")
        user_data = response.json()

    # Compute features
    features = {
        'age_squared': user_data['age'] ** 2,
        'income_per_age': user_data['income'] / user_data['age']
    }

    return features

@app.get("/features/{user_id}")
async def get_features(user_id: str):
    """Retrieve precomputed features"""
    # From Redis or Feature Store
    features = redis.hgetall(f"features:{user_id}")
    return features


# model_serving.py - Independent microservice
from fastapi import FastAPI
import httpx
import joblib

app = FastAPI(title="Model Serving Service")

# Load model at startup
model = joblib.load('model.pkl')
scaler = joblib.load('scaler.pkl')

@app.post("/predict")
async def predict(user_id: str):
    """Generate prediction for user"""
    # Fetch features from Feature Service
    async with httpx.AsyncClient() as client:
        response = await client.get(
            f"http://feature-service/features/{user_id}"
        )
        features = response.json()

    # Convert to array
    feature_array = [[features['age_squared'], features['income_per_age']]]

    # Scale and predict
    feature_scaled = scaler.transform(feature_array)
    prediction = model.predict_proba(feature_scaled)[0, 1]

    return {
        "user_id": user_id,
        "prediction": float(prediction),
        "model_version": "v1.2.0"
    }

@app.get("/health")
async def health():
    """Health check endpoint"""
    return {"status": "healthy", "model_loaded": model is not None}


# docker-compose.yml - Deploy all services
"""
version: '3.8'

services:
  data-service:
    build: ./data_service
    ports:
      - "8001:8000"
    environment:
      - SERVICE_NAME=data-service

  feature-service:
    build: ./feature_service
    ports:
      - "8002:8000"
    environment:
      - DATA_SERVICE_URL=http://data-service:8000
    depends_on:
      - data-service

  model-serving:
    build: ./model_serving
    ports:
      - "8003:8000"
    environment:
      - FEATURE_SERVICE_URL=http://feature-service:8000
    depends_on:
      - feature-service

  api-gateway:
    image: kong:latest
    ports:
      - "8000:8000"
    environment:
      - KONG_PROXY_ACCESS_LOG=/dev/stdout
"""
```

**Pros:**
- ‚úÖ Independent scaling (scale serving without scaling training)
- ‚úÖ Independent deployment (update features without touching serving)
- ‚úÖ Technology flexibility (Python for ML, Java for APIs)
- ‚úÖ Team autonomy (different teams own different services)
- ‚úÖ Fault isolation (feature service down doesn't crash serving)

**Cons:**
- ‚ùå Network latency (service-to-service calls)
- ‚ùå Complex deployment and orchestration
- ‚ùå Distributed debugging challenges
- ‚ùå Data consistency challenges
- ‚ùå Requires DevOps/infrastructure expertise

**When to Use:**
- Large teams (15+ people)
- Large datasets (1TB+)
- High request volume (1K+ QPS)
- Need for independent scaling
- Multiple ML models

---

### 2. Event-Driven ML Architecture

**Description:** ML components communicate asynchronously via events/messages.

**Architecture:**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Data Source  ‚îÇ                    ‚îÇ Prediction   ‚îÇ
‚îÇ   (API)      ‚îÇ                    ‚îÇ   Request    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ Publish                            ‚îÇ Publish
       ‚îÇ "data.created"                     ‚îÇ "predict.requested"
       ‚Üì                                    ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              Event Broker (Kafka/RabbitMQ)          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ                         ‚îÇ                 ‚îÇ
       ‚îÇ Subscribe               ‚îÇ Subscribe       ‚îÇ Subscribe
       ‚Üì                         ‚Üì                 ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Feature     ‚îÇ         ‚îÇ   Training   ‚îÇ  ‚îÇ   Serving    ‚îÇ
‚îÇ Engineering  ‚îÇ         ‚îÇ   Service    ‚îÇ  ‚îÇ   Service    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ Publish                ‚îÇ Publish          ‚îÇ Publish
       ‚îÇ "features.computed"    ‚îÇ "model.trained"  ‚îÇ "prediction.made"
       ‚Üì                        ‚Üì                  ‚Üì
     [Event Broker]          [Event Broker]    [Event Broker]
```

**Implementation:**
```python
# event_driven_ml.py

from kafka import KafkaProducer, KafkaConsumer
import json
from typing import Callable

class EventBus:
    """Event bus for ML system communication"""

    def __init__(self, bootstrap_servers: str = 'localhost:9092'):
        self.producer = KafkaProducer(
            bootstrap_servers=bootstrap_servers,
            value_serializer=lambda v: json.dumps(v).encode('utf-8')
        )

    def publish(self, topic: str, event: dict):
        """Publish event to topic"""
        self.producer.send(topic, value=event)
        self.producer.flush()
        print(f"üì§ Published to {topic}: {event.get('event_type', 'unknown')}")

    def subscribe(self, topic: str, handler: Callable):
        """Subscribe to topic and handle events"""
        consumer = KafkaConsumer(
            topic,
            bootstrap_servers='localhost:9092',
            value_deserializer=lambda m: json.loads(m.decode('utf-8')),
            auto_offset_reset='earliest',
            group_id='ml-system'
        )

        print(f"üì• Subscribed to {topic}")

        for message in consumer:
            event = message.value
            handler(event)


# Feature Engineering Service (Event-Driven)
class FeatureEngineeringService:
    """Listens for data events, computes features, publishes results"""

    def __init__(self, event_bus: EventBus):
        self.event_bus = event_bus

    def start(self):
        """Start listening for data events"""
        self.event_bus.subscribe('data.ingested', self.handle_data_ingested)

    def handle_data_ingested(self, event: dict):
        """Handle data ingestion event"""
        user_id = event['user_id']
        data = event['data']

        print(f"üîß Computing features for user {user_id}")

        # Compute features
        features = {
            'age_squared': data['age'] ** 2,
            'income_per_age': data['income'] / data['age']
        }

        # Publish features computed event
        self.event_bus.publish('features.computed', {
            'event_type': 'features.computed',
            'user_id': user_id,
            'features': features,
            'timestamp': datetime.now().isoformat()
        })


# Training Service (Event-Driven)
class TrainingService:
    """Listens for training triggers, trains models, publishes results"""

    def __init__(self, event_bus: EventBus):
        self.event_bus = event_bus

    def start(self):
        """Start listening for training events"""
        self.event_bus.subscribe('training.requested', self.handle_training_requested)

    def handle_training_requested(self, event: dict):
        """Handle training request event"""
        dataset_version = event['dataset_version']

        print(f"üèãÔ∏è Training model on dataset {dataset_version}")

        # Load data
        training_data = load_training_data(dataset_version)

        # Train model
        model = train_model(training_data)

        # Save model
        model_version = save_model(model)

        # Publish model trained event
        self.event_bus.publish('model.trained', {
            'event_type': 'model.trained',
            'model_version': model_version,
            'dataset_version': dataset_version,
            'metrics': {'auc': 0.89},
            'timestamp': datetime.now().isoformat()
        })


# Serving Service (Event-Driven)
class ServingService:
    """Listens for prediction requests, generates predictions"""

    def __init__(self, event_bus: EventBus):
        self.event_bus = event_bus
        self.model = load_latest_model()

        # Subscribe to model updates
        self.event_bus.subscribe('model.trained', self.handle_model_trained)

    def start(self):
        """Start listening for prediction requests"""
        self.event_bus.subscribe('prediction.requested', self.handle_prediction_requested)

    def handle_model_trained(self, event: dict):
        """Reload model when new version is available"""
        model_version = event['model_version']
        print(f"üîÑ Loading new model version: {model_version}")
        self.model = load_model(model_version)

    def handle_prediction_requested(self, event: dict):
        """Handle prediction request event"""
        user_id = event['user_id']
        features = event['features']

        # Generate prediction
        prediction = self.model.predict_proba([features])[0, 1]

        # Publish prediction made event
        self.event_bus.publish('prediction.made', {
            'event_type': 'prediction.made',
            'user_id': user_id,
            'prediction': float(prediction),
            'model_version': self.model.version,
            'timestamp': datetime.now().isoformat()
        })


# Start all services
if __name__ == '__main__':
    event_bus = EventBus()

    # Start services
    feature_service = FeatureEngineeringService(event_bus)
    feature_service.start()

    training_service = TrainingService(event_bus)
    training_service.start()

    serving_service = ServingService(event_bus)
    serving_service.start()

    # Simulate data ingestion event
    event_bus.publish('data.ingested', {
        'event_type': 'data.ingested',
        'user_id': 'user_123',
        'data': {'age': 35, 'income': 50000}
    })
```

**Pros:**
- ‚úÖ Loose coupling (services don't need to know about each other)
- ‚úÖ Asynchronous processing (no waiting for responses)
- ‚úÖ Scalability (add more consumers for high throughput)
- ‚úÖ Resilience (messages persist if service is down)
- ‚úÖ Event sourcing (audit trail of all events)

**Cons:**
- ‚ùå Eventual consistency (not suitable for real-time needs)
- ‚ùå Debugging complexity (hard to trace event flows)
- ‚ùå Message broker as single point of failure
- ‚ùå Ordering guarantees can be complex

**When to Use:**
- Asynchronous ML workflows (batch retraining)
- High-throughput data ingestion
- Event sourcing requirements (audit trails)
- Decoupled system evolution

---

### 3. Service Mesh Architecture

**Description:** Microservices with dedicated infrastructure layer (service mesh) handling inter-service communication, observability, and security.

**Architecture:**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              Service Mesh (Istio/Linkerd)           ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ   Traffic Management, Security, Observability‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                                                     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îÇ
‚îÇ  ‚îÇ Feature  ‚îÇ   ‚îÇ Training ‚îÇ   ‚îÇ Serving  ‚îÇ      ‚îÇ
‚îÇ  ‚îÇ Service  ‚îÇ   ‚îÇ Service  ‚îÇ   ‚îÇ Service  ‚îÇ      ‚îÇ
‚îÇ  ‚îÇ  +Proxy  ‚îÇ   ‚îÇ  +Proxy  ‚îÇ   ‚îÇ  +Proxy  ‚îÇ      ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Key Features:**
- **Traffic Management:** A/B testing, canary deployments, circuit breaking
- **Security:** mTLS between services, authentication, authorization
- **Observability:** Distributed tracing, metrics collection, logging

**Implementation (Istio):**
```yaml
# istio-config.yaml

# VirtualService for model serving with traffic splitting
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: model-serving
spec:
  hosts:
  - model-serving
  http:
  - match:
    - headers:
        x-user-group:
          exact: beta
    route:
    - destination:
        host: model-serving
        subset: v2
      weight: 100
  - route:
    - destination:
        host: model-serving
        subset: v1
      weight: 90
    - destination:
        host: model-serving
        subset: v2
      weight: 10  # 10% canary traffic

---
# DestinationRule for circuit breaking
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: model-serving
spec:
  host: model-serving
  trafficPolicy:
    connectionPool:
      tcp:
        maxConnections: 100
      http:
        http1MaxPendingRequests: 50
        http2MaxRequests: 100
        maxRequestsPerConnection: 2
    outlierDetection:
      consecutiveErrors: 5
      interval: 30s
      baseEjectionTime: 30s
      maxEjectionPercent: 50
  subsets:
  - name: v1
    labels:
      version: v1
  - name: v2
    labels:
      version: v2

---
# AuthorizationPolicy for model access control
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: model-serving-authz
spec:
  selector:
    matchLabels:
      app: model-serving
  rules:
  - from:
    - source:
        principals:
        - "cluster.local/ns/default/sa/api-gateway"
    to:
    - operation:
        methods: ["POST"]
        paths: ["/predict"]
```

**Observability with Istio:**
```python
# Python service with Istio integration

from fastapi import FastAPI, Request
from opentelemetry import trace
from opentelemetry.exporter.jaeger import JaegerExporter
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor

app = FastAPI()

# Configure distributed tracing
trace.set_tracer_provider(TracerProvider())
jaeger_exporter = JaegerExporter(
    agent_host_name="jaeger-agent",
    agent_port=6831
)
trace.get_tracer_provider().add_span_processor(
    BatchSpanProcessor(jaeger_exporter)
)

tracer = trace.get_tracer(__name__)

@app.post("/predict")
async def predict(request: Request):
    """Prediction endpoint with distributed tracing"""

    # Extract trace context from Istio headers
    with tracer.start_as_current_span("model-prediction") as span:
        span.set_attribute("model.version", "v2.0")
        span.set_attribute("user.id", request.headers.get("x-user-id"))

        # Call feature service (traced automatically by Istio)
        features = await get_features(user_id)

        # Predict
        with tracer.start_as_current_span("model-inference"):
            prediction = model.predict(features)

        span.set_attribute("prediction.score", prediction)

        return {"prediction": prediction}
```

**Pros:**
- ‚úÖ Zero-code observability (automatic tracing)
- ‚úÖ Advanced traffic management (canary, A/B testing)
- ‚úÖ Security by default (mTLS)
- ‚úÖ Consistent policies across services

**Cons:**
- ‚ùå Added complexity (learning curve)
- ‚ùå Performance overhead (proxy sidecar)
- ‚ùå Requires Kubernetes

**When to Use:**
- Large-scale microservices (10+ services)
- Complex traffic routing needs
- Security and compliance requirements
- Need for advanced observability

---

## üí° Practical Examples

### Example 1: Real-World E-Commerce Recommendation System

**Requirements:**
- Personalized recommendations for 10M users
- <100ms latency for recommendations
- Real-time behavior tracking
- A/B testing new models
- Independent scaling of components

**Architecture:**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    API Gateway (Kong)                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                      ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚Üì             ‚Üì             ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ User        ‚îÇ ‚îÇ Product     ‚îÇ ‚îÇ Search      ‚îÇ
‚îÇ Service     ‚îÇ ‚îÇ Service     ‚îÇ ‚îÇ Service     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚îÇ             ‚îÇ             ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                      ‚Üì
               ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
               ‚îÇ  Feature    ‚îÇ
               ‚îÇ  Service    ‚îÇ
               ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                      ‚Üì
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚Üì                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Candidate   ‚îÇ            ‚îÇ   Ranking    ‚îÇ
‚îÇ  Generation  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí‚îÇ   Service    ‚îÇ
‚îÇ  Service     ‚îÇ            ‚îÇ              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                   ‚Üì
                            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                            ‚îÇ   Response   ‚îÇ
                            ‚îÇ  Assembly    ‚îÇ
                            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Implementation Highlights:**

```python
# recommendation_system.py

class RecommendationSystem:
    """
    Microservices-based recommendation system
    """

    def __init__(self):
        self.feature_service_url = "http://feature-service:8000"
        self.candidate_service_url = "http://candidate-service:8001"
        self.ranking_service_url = "http://ranking-service:8002"

    async def get_recommendations(
        self,
        user_id: str,
        context: dict,
        num_items: int = 10
    ) -> List[str]:
        """
        Generate personalized recommendations

        Flow:
        1. Get user features (parallel with candidates)
        2. Generate candidates (collaborative filtering, 1000 items)
        3. Rank candidates (ML model, top 10)
        4. Return results
        """
        async with httpx.AsyncClient() as client:
            # Parallel requests for features and candidates
            user_features_task = client.get(
                f"{self.feature_service_url}/user/{user_id}"
            )
            candidates_task = client.post(
                f"{self.candidate_service_url}/generate",
                json={"user_id": user_id, "top_k": 1000}
            )

            # Wait for both
            user_features_response, candidates_response = await asyncio.gather(
                user_features_task,
                candidates_task
            )

            user_features = user_features_response.json()
            candidates = candidates_response.json()['items']

            # Rank candidates
            ranking_response = await client.post(
                f"{self.ranking_service_url}/rank",
                json={
                    "user_id": user_id,
                    "candidates": candidates,
                    "user_features": user_features,
                    "context": context
                }
            )

            ranked_items = ranking_response.json()['ranked_items']

            return ranked_items[:num_items]
```

---

### Example 2: Fraud Detection with Event-Driven Architecture

**Requirements:**
- Real-time transaction scoring (<50ms)
- Asynchronous model retraining
- Event sourcing for audit trails
- Feedback loop from fraud investigators

**Architecture:**
```
Transaction ‚Üí Kafka ‚Üí [Stream Processing] ‚Üí Redis (Features)
                ‚Üì                                    ‚Üì
            [Storage]                         [Scoring Service]
                ‚Üì                                    ‚Üì
        [Training Pipeline]                    Decision
                ‚Üì
          Updated Model ‚Üí Model Registry ‚Üí [Scoring Service]
```

**Implementation:**
```python
# Fraud detection with event-driven architecture

from kafka import KafkaProducer, KafkaConsumer
import json

class FraudDetectionSystem:
    """Event-driven fraud detection"""

    def __init__(self):
        self.kafka_producer = KafkaProducer(
            bootstrap_servers='kafka:9092',
            value_serializer=lambda v: json.dumps(v).encode()
        )

    def process_transaction(self, transaction: dict):
        """
        Process transaction and publish events
        """
        # Publish transaction event
        self.kafka_producer.send('transactions', value={
            'event_type': 'transaction.created',
            'transaction_id': transaction['id'],
            'user_id': transaction['user_id'],
            'amount': transaction['amount'],
            'merchant_id': transaction['merchant_id'],
            'timestamp': datetime.now().isoformat()
        })

        # Real-time scoring service consumes from Kafka
        # Async training service also consumes for retraining
```

---

## üîß Code Examples

### Complete Microservices ML System with Docker Compose

```yaml
# docker-compose.yml

version: '3.8'

services:
  # API Gateway
  api-gateway:
    image: kong:latest
    ports:
      - "8000:8000"
      - "8001:8001"
    environment:
      KONG_DATABASE: "off"
      KONG_PROXY_ACCESS_LOG: /dev/stdout
      KONG_ADMIN_ACCESS_LOG: /dev/stdout
      KONG_PROXY_ERROR_LOG: /dev/stderr
      KONG_ADMIN_ERROR_LOG: /dev/stderr

  # Data Service
  data-service:
    build: ./services/data
    environment:
      - DATABASE_URL=postgresql://db:5432/ml_data
      - REDIS_URL=redis://redis:6379
    depends_on:
      - db
      - redis

  # Feature Service
  feature-service:
    build: ./services/features
    environment:
      - DATA_SERVICE_URL=http://data-service:8000
      - REDIS_URL=redis://redis:6379
    depends_on:
      - data-service
      - redis

  # Model Training Service
  training-service:
    build: ./services/training
    environment:
      - FEATURE_SERVICE_URL=http://feature-service:8000
      - MLFLOW_TRACKING_URI=http://mlflow:5000
      - S3_BUCKET=ml-models
    depends_on:
      - feature-service
      - mlflow

  # Model Serving Service
  serving-service:
    build: ./services/serving
    deploy:
      replicas: 3
    environment:
      - FEATURE_SERVICE_URL=http://feature-service:8000
      - MODEL_REGISTRY_URL=http://mlflow:5000
    depends_on:
      - feature-service
      - mlflow

  # Supporting Infrastructure
  db:
    image: postgres:14
    environment:
      POSTGRES_DB: ml_data
      POSTGRES_USER: ml_user
      POSTGRES_PASSWORD: ml_password
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7
    ports:
      - "6379:6379"

  kafka:
    image: confluentinc/cp-kafka:latest
    environment:
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:9092

  zookeeper:
    image: confluentinc/cp-zookeeper:latest
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181

  mlflow:
    image: mlflow/mlflow:latest
    ports:
      - "5000:5000"
    command: mlflow server --host 0.0.0.0 --port 5000

  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml

  grafana:
    image: grafana/grafana:latest
    ports:
      - "3000:3000"
    depends_on:
      - prometheus

volumes:
  postgres_data:
```

---

## ‚úÖ Best Practices

### 1. Start Simple, Evolve Gradually
- Begin with monolith for prototypes
- Move to modular as team grows
- Adopt microservices when scaling challenges emerge
- Don't over-engineer early

### 2. Design for Loose Coupling
- Services should be independently deployable
- Use APIs or events for communication
- Avoid shared databases between services
- Version all interfaces

### 3. Implement API Contracts
- Use OpenAPI/Swagger for REST APIs
- Define message schemas for events (Avro, Protobuf)
- Version APIs to avoid breaking changes
- Test contract compliance

### 4. Embrace Observability from Day 1
- Distributed tracing (Jaeger, Zipkin)
- Centralized logging (ELK stack)
- Metrics collection (Prometheus)
- Dashboards (Grafana)

### 5. Design for Failure
- Circuit breakers for downstream failures
- Timeouts on all external calls
- Graceful degradation (fallbacks)
- Health checks and readiness probes

### 6. Use Domain-Driven Design
- Organize services around business domains
- Feature service, Training service, Serving service
- Clear boundaries and responsibilities
- Avoid distributed monoliths

### 7. Automate Everything
- CI/CD pipelines for each service
- Infrastructure as Code (Terraform, Pulumi)
- Automated testing (unit, integration, contract)
- Automated rollbacks

### 8. Secure by Default
- mTLS between services
- Authentication and authorization
- Secrets management (Vault, AWS Secrets Manager)
- Network policies (least privilege)

---

## ‚ö†Ô∏è Common Pitfalls

### 1. Premature Microservices

**Problem:** Starting with microservices for a prototype.

**Solution:** Start monolithic, extract services when scaling needs emerge.

---

### 2. Chatty Services

**Problem:** Too many synchronous API calls between services (N+1 problem).

**Solution:**
- Batch requests
- Cache frequently accessed data
- Use async events where possible

---

### 3. Shared Database Anti-Pattern

**Problem:** Multiple services accessing same database.

**Solution:** Each service owns its data, expose via APIs.

---

### 4. Lack of Observability

**Problem:** Can't debug distributed system issues.

**Solution:** Implement distributed tracing, logging, metrics from start.

---

### 5. Ignoring Network Failures

**Problem:** Assuming network is reliable.

**Solution:**
- Implement retries with exponential backoff
- Circuit breakers
- Timeouts on all calls

---

## üèãÔ∏è Hands-On Exercises

### Exercise 1: Migrate Monolith to Microservices

**Difficulty:** Advanced
**Time:** 10-12 hours

**Objective:** Refactor a monolithic ML application into microservices.

**Given:** Monolithic fraud detection app (single codebase)

**Tasks:**
1. Identify service boundaries (data, features, training, serving)
2. Extract Feature Service as first microservice
3. Implement API contracts (OpenAPI)
4. Deploy with Docker Compose
5. Measure performance (latency, throughput)

**Validation:**
- Services deploy independently
- Can update Feature Service without touching Serving
- Latency increase <20ms

---

### Exercise 2: Implement Event-Driven Architecture

**Difficulty:** Advanced
**Time:** 8-10 hours

**Objective:** Convert synchronous ML pipeline to event-driven.

**Tasks:**
1. Set up Kafka
2. Create events: `data.ingested`, `features.computed`, `model.trained`
3. Implement event handlers for each service
4. Visualize event flow with distributed tracing

**Deliverables:**
- Event schemas (Avro)
- Publisher/subscriber code
- Event flow diagram

---

### Exercise 3: Service Mesh with Istio

**Difficulty:** Advanced
**Time:** 8-10 hours

**Objective:** Deploy ML microservices with Istio service mesh.

**Tasks:**
1. Install Istio on Kubernetes
2. Deploy ML services with Istio sidecars
3. Implement canary deployment (90/10 traffic split)
4. Configure circuit breakers
5. View metrics in Grafana

**Validation:**
- mTLS enabled between services
- Canary deployment working
- Circuit breaker triggers on failures

---

### Exercise 4: Design ML Architecture for Use Case

**Difficulty:** Intermediate
**Time:** 4-5 hours

**Objective:** Design architecture for real-time personalization system.

**Requirements:**
- 100M users
- <50ms latency
- A/B testing
- Real-time feature updates

**Deliverables:**
- Architecture diagram
- Service breakdown
- Technology choices
- Scaling strategy

---

## üìö Further Reading

### Essential Books

1. **"Building Microservices" by Sam Newman**
   - Definitive guide to microservices architecture
   - Practical patterns and anti-patterns

2. **"Designing Data-Intensive Applications" by Martin Kleppmann**
   - Chapter 11: Stream Processing
   - Chapter 12: Future of Data Systems

3. **"Software Architecture: The Hard Parts" by Neal Ford et al.**
   - Trade-off analysis
   - Modern architecture patterns

### Key Papers

1. **"Hidden Technical Debt in Machine Learning Systems"** (Google, 2015)
   - [Paper](https://papers.nips.cc/paper/2015/hash/86df7dcfd896fcaf2674f757a2463eba-Abstract.html)
   - Foundational paper on ML system architecture

### Blogs and Documentation

1. **Uber Engineering Blog**
   - ["Michelangelo: Uber's Machine Learning Platform"](https://www.uber.com/blog/michelangelo-machine-learning-platform/)

2. **Netflix Tech Blog**
   - ["Architecting for Resilience"](https://netflixtechblog.com/)

3. **Istio Documentation**
   - [Istio Docs](https://istio.io/latest/docs/)

4. **AWS ML Architecture**
   - [AWS ML Architecture Center](https://aws.amazon.com/architecture/machine-learning/)

### Video Courses

1. **"Microservices Architecture" (Udemy)**
   - Practical implementation patterns

2. **"Building ML Platforms" (Pluralsight)**
   - End-to-end ML architecture

---

## üìù Key Takeaways

1. **Start Simple, Evolve Based on Needs**
   - Monolith ‚Üí Modular ‚Üí Microservices
   - Don't over-engineer early

2. **Choose Architecture Based on Requirements**
   - Latency requirements ‚Üí Synchronous vs Async
   - Scale requirements ‚Üí Monolith vs Microservices
   - Team size ‚Üí Centralized vs Distributed

3. **Microservices Enable Scale and Autonomy**
   - Independent scaling and deployment
   - Team autonomy
   - Technology flexibility

4. **Event-Driven for Asynchronous Workflows**
   - Training pipelines
   - Data ingestion
   - Audit trails

5. **Service Mesh for Advanced Features**
   - Traffic management
   - Security (mTLS)
   - Observability

6. **Design for Failure**
   - Circuit breakers
   - Timeouts
   - Graceful degradation

7. **Observability is Essential**
   - Distributed tracing
   - Centralized logging
   - Metrics and alerts

8. **API Contracts Prevent Breaking Changes**
   - OpenAPI for REST
   - Schema registry for events
   - Versioning strategy

9. **Domain-Driven Design for Clear Boundaries**
   - Services around business capabilities
   - Avoid distributed monoliths

10. **Automate Infrastructure**
    - IaC (Terraform, Pulumi)
    - CI/CD for services
    - Automated testing

---

## üìù Notes Section

### My Key Insights:
-

### Questions to Explore Further:
-

### How This Applies to My Work:
-

### Tools to Investigate:
-

### Action Items:
-

---

## üîó Related Concepts

- [[01_Projects/DEforAI/Course/02. ML Data Pipeline Lifecycle/README|Chapter 2: ML Data Pipeline Lifecycle]]
- [[02. Lambda vs Kappa Architectures for ML|Next: Lambda vs Kappa]]
- [[03. Batch vs Streaming Considerations|Next: Batch vs Streaming]]

---

*Created: October 18, 2025*
*Last Updated: October 18, 2025*
*Status: ‚úÖ Completed - Ready for study*
